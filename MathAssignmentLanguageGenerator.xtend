/*
 * generated by Xtext 2.24.0
 */
package dk.sdu.mmmi.mdsd.generator

import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Div
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Exp
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Exp1
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.MathExp
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Minus
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Mult
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Number
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Parenthesis
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Plus
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Primary
import javax.swing.JOptionPane
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
 
 
 
class MathAssignmentLanguageGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val math = resource.allContents.filter(MathExp).next
		val result = math.compute
		System.out.println("Math expression = "+math.display)
		// For +1 score, replace with hovering, see Bettini Chapter 8
		JOptionPane.showMessageDialog(null, "result = "+result,"Math Language", JOptionPane.INFORMATION_MESSAGE)
	}
	
	//
	// Compute function: computes value of expression
	// Note: written according to illegal left-recursive grammar, requires fix
	//
	
	def static int compute(MathExp math) { 
		math.exp.computeExp
	}
	
	static int addition = 0
	static int subtract = 0
	
	def static int computeExp(Exp exp) {
		
		val left = exp.left.computePrim
		addition = addition + left
		
		switch exp.operator {
			Plus: { 
				
				switch exp.right.operator {
					Mult: {
						addition = addition + (exp.right.left.computePrim * exp.right.right.left.computePrim)
						exp.right.right.computeExp
					}
					Div: {
						addition = addition + (exp.right.left.computePrim / exp.right.right.left.computePrim)
						exp.right.right.computeExp
					}
					default: {
						addition = addition + exp.right.left.computePrim
						exp.right.computeExp
					}
				}
				
			}
			Minus: { 
				
				switch exp.right.operator {
					Mult: {
						subtract = subtract + (exp.right.left.computePrim * exp.right.right.left.computePrim)
						exp.right.right.computeExp
					}
					Div: {
						subtract = subtract + (exp.right.left.computePrim / exp.right.right.left.computePrim)
						exp.right.right.computeExp
					}
					default: {
						subtract = subtract + exp.right.left.computePrim
						exp.right.computeExp
					}
				}
			}
			Mult: { 
				
				addition = addition * exp.right.left.computePrim
				exp.right.computeExp
				
			}
			Div: { 
				
				addition = addition / exp.right.left.computePrim
				exp.right.computeExp
				
			}
			default: {
				val test = addition - subtract
				addition = 0
				subtract = 0
				return test
			}
		}
	}
	
	
	def static int computeExp(Exp1 exp) {
		
		switch exp.operator {
			Plus: { 
				
				switch exp.right.operator {
					Mult: {
						addition = addition + (exp.right.left.computePrim * exp.right.right.left.computePrim)
						exp.right.right.computeExp
					}
					Div: {
						addition = addition + (exp.right.left.computePrim / exp.right.right.left.computePrim)
						exp.right.right.computeExp
					}
					default: {
						addition = addition + exp.right.left.computePrim
						exp.right.computeExp
					}
				}
				
			}
			Minus: { 
				
				switch exp.right.operator {
					Mult: {
						subtract = subtract + (exp.right.left.computePrim * exp.right.right.left.computePrim)
						exp.right.right.computeExp
					}
					Div: {
						subtract = subtract + (exp.right.left.computePrim / exp.right.right.left.computePrim)
						exp.right.right.computeExp
					}
					default: {
						subtract = subtract + exp.right.left.computePrim
						exp.right.computeExp
					}
				}
			}
			
			Mult: { 
				
				addition = addition * exp.right.left.computePrim
				exp.right.computeExp
				
			}
			Div: { 
				
				addition = addition / exp.right.left.computePrim
				exp.right.computeExp
				
			}
			default: {
				val test = addition - subtract
				addition = 0
				subtract = 0
				return test
			}
		}
	}
	
	def static int computePrim(Primary factor) { 
		switch factor {
			Number : factor.value
			Parenthesis: (factor.exp.computeExp)
			default: 87
		}
	}

	//
	// Display function: show complete syntax tree
	// Note: written according to illegal left-recursive grammar, requires fix
	//

	def CharSequence display(MathExp math) '''Math[«math.exp.displayExp»]'''
	def CharSequence displayExp(Exp exp) '''Exp[«exp.left.displayFactor»,«exp.operator?.displayOp»,«exp.right.left?.displayFactor»]'''
	def dispatch String displayOp(Plus op)  { "+" }
	def dispatch String displayOp(Minus op) { "-" }
	def dispatch String displayOp(Mult op) { "*" }
	def dispatch String displayOp(Div op) { "/" }
	def CharSequence displayFactor(Primary primary) { "?" }
	
		
}